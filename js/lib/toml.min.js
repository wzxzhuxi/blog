/**
 * Minimal TOML Parser
 *
 * Supports:
 * - [section] and [section.subsection]
 * - [[array_of_tables]]
 * - key = "string"
 * - key = 123 (integers)
 * - key = true/false (booleans)
 * - key = [1, 2, 3] (arrays)
 * - key = { inline = "table" } (inline tables)
 * - # comments
 */
var toml = (function() {
  'use strict';

  function parse(input) {
    var result = {};
    var currentSection = result;
    var currentArrayTable = null;
    var lines = input.split(/\r?\n/);

    for (var i = 0; i < lines.length; i++) {
      var line = lines[i].trim();

      // Skip empty lines and comments
      if (!line || line.charAt(0) === '#') {
        continue;
      }

      // Handle array of tables [[name]]
      var arrayMatch = line.match(/^\[\[([^\]]+)\]\]$/);
      if (arrayMatch) {
        var arrayPath = arrayMatch[1].trim().split('.');
        var target = result;

        for (var j = 0; j < arrayPath.length - 1; j++) {
          var key = arrayPath[j].trim();
          if (!target[key]) {
            target[key] = {};
          }
          target = target[key];
        }

        var lastKey = arrayPath[arrayPath.length - 1].trim();
        if (!target[lastKey]) {
          target[lastKey] = [];
        }

        currentArrayTable = {};
        target[lastKey].push(currentArrayTable);
        currentSection = currentArrayTable;
        continue;
      }

      // Handle section [name]
      var sectionMatch = line.match(/^\[([^\]]+)\]$/);
      if (sectionMatch) {
        var sectionPath = sectionMatch[1].trim().split('.');
        currentSection = result;
        currentArrayTable = null;

        for (var k = 0; k < sectionPath.length; k++) {
          var sectionKey = sectionPath[k].trim();
          if (!currentSection[sectionKey]) {
            currentSection[sectionKey] = {};
          }
          currentSection = currentSection[sectionKey];
        }
        continue;
      }

      // Handle key = value
      var eqIndex = line.indexOf('=');
      if (eqIndex > 0) {
        var keyName = line.substring(0, eqIndex).trim();
        var rawValue = line.substring(eqIndex + 1).trim();

        currentSection[keyName] = parseValue(rawValue);
      }
    }

    return result;
  }

  function parseValue(raw) {
    if (!raw) return '';

    raw = raw.trim();

    // Boolean
    if (raw === 'true') return true;
    if (raw === 'false') return false;

    // Integer
    if (/^-?\d+$/.test(raw)) {
      return parseInt(raw, 10);
    }

    // Float
    if (/^-?\d+\.\d+$/.test(raw)) {
      return parseFloat(raw);
    }

    // Basic string "..."
    if (raw.charAt(0) === '"') {
      return parseBasicString(raw);
    }

    // Literal string '...'
    if (raw.charAt(0) === "'") {
      return parseLiteralString(raw);
    }

    // Array [...]
    if (raw.charAt(0) === '[') {
      return parseArray(raw);
    }

    // Inline table {...}
    if (raw.charAt(0) === '{') {
      return parseInlineTable(raw);
    }

    // Remove trailing comment for unquoted values
    var commentIdx = raw.indexOf('#');
    if (commentIdx > 0) {
      raw = raw.substring(0, commentIdx).trim();
    }

    return raw;
  }

  function parseBasicString(raw) {
    var content = '';
    var i = 1;

    while (i < raw.length) {
      var char = raw.charAt(i);

      if (char === '\\' && i + 1 < raw.length) {
        var next = raw.charAt(i + 1);
        if (next === 'n') { content += '\n'; i += 2; continue; }
        if (next === 't') { content += '\t'; i += 2; continue; }
        if (next === 'r') { content += '\r'; i += 2; continue; }
        if (next === '\\') { content += '\\'; i += 2; continue; }
        if (next === '"') { content += '"'; i += 2; continue; }
        content += char;
        i++;
        continue;
      }

      if (char === '"') {
        break;
      }

      content += char;
      i++;
    }

    return content;
  }

  function parseLiteralString(raw) {
    var end = raw.indexOf("'", 1);
    if (end === -1) end = raw.length;
    return raw.substring(1, end);
  }

  function parseArray(raw) {
    var result = [];
    var content = extractBracketContent(raw, '[', ']');
    if (!content) return result;

    var items = splitTopLevel(content, ',');

    for (var i = 0; i < items.length; i++) {
      var item = items[i].trim();
      if (item) {
        result.push(parseValue(item));
      }
    }

    return result;
  }

  function parseInlineTable(raw) {
    var result = {};
    var content = extractBracketContent(raw, '{', '}');
    if (!content) return result;

    var pairs = splitTopLevel(content, ',');

    for (var i = 0; i < pairs.length; i++) {
      var pair = pairs[i].trim();
      var eqIdx = pair.indexOf('=');

      if (eqIdx > 0) {
        var key = pair.substring(0, eqIdx).trim();
        var value = pair.substring(eqIdx + 1).trim();
        result[key] = parseValue(value);
      }
    }

    return result;
  }

  function extractBracketContent(raw, openBracket, closeBracket) {
    var start = raw.indexOf(openBracket);
    if (start === -1) return '';

    var depth = 0;
    var end = -1;

    for (var i = start; i < raw.length; i++) {
      var char = raw.charAt(i);

      // Skip strings
      if (char === '"' || char === "'") {
        var quote = char;
        i++;
        while (i < raw.length) {
          if (raw.charAt(i) === '\\') {
            i++;
          } else if (raw.charAt(i) === quote) {
            break;
          }
          i++;
        }
        continue;
      }

      if (char === openBracket) {
        depth++;
      } else if (char === closeBracket) {
        depth--;
        if (depth === 0) {
          end = i;
          break;
        }
      }
    }

    if (end === -1) return '';
    return raw.substring(start + 1, end);
  }

  function splitTopLevel(content, separator) {
    var result = [];
    var current = '';
    var depth = 0;
    var inString = false;
    var stringChar = null;

    for (var i = 0; i < content.length; i++) {
      var char = content.charAt(i);
      var prevChar = i > 0 ? content.charAt(i - 1) : '';

      // Handle string boundaries
      if ((char === '"' || char === "'") && prevChar !== '\\') {
        if (!inString) {
          inString = true;
          stringChar = char;
        } else if (char === stringChar) {
          inString = false;
          stringChar = null;
        }
      }

      if (!inString) {
        if (char === '[' || char === '{') depth++;
        if (char === ']' || char === '}') depth--;

        if (char === separator && depth === 0) {
          result.push(current);
          current = '';
          continue;
        }
      }

      current += char;
    }

    if (current.trim()) {
      result.push(current);
    }

    return result;
  }

  return {
    parse: parse
  };
})();

// Export for Node.js
if (typeof module !== 'undefined' && module.exports) {
  module.exports = toml;
}
